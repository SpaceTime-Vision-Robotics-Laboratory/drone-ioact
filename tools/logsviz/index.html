<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>robobase logsviz</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      background: #0f0f23;
      color: #ccc;
      font-family: "Courier New", monospace;
      overflow: hidden;
    }

    #header {
      padding: 12px 20px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      border-bottom: 1px solid #222;
    }

    #header h1 {
      font-size: 15px;
      color: #4cc9f0;
      font-weight: normal;
    }

    #status {
      font-size: 11px;
      color: #555;
    }

    #container {
      padding: 20px;
    }

    canvas {
      display: block;
      cursor: crosshair;
    }

    #tooltip {
      position: fixed;
      display: none;
      background: #1e1e38;
      border: 1px solid #444;
      border-radius: 4px;
      padding: 8px 12px;
      font-size: 11px;
      color: #ddd;
      pointer-events: none;
      z-index: 100;
      max-width: 420px;
      white-space: pre;
      line-height: 1.5;
    }

    #tooltip b {
      color: #fff;
    }

    #info {
      padding: 8px 20px;
      font-size: 10px;
      color: #444;
      border-top: 1px solid #1a1a1a;
    }
  </style>
</head>
<body>

<div id="header">
  <h1>robobase logsviz</h1>
  <span id="status">connecting...</span>
</div>

<div id="container">
  <canvas id="canvas"></canvas>
</div>

<div id="tooltip"></div>

<div id="info">scroll to zoom &middot; drag to pan &middot; double-click to reset</div>

<script>
// ---------------------------------------------------------------------------
// DOM refs
// ---------------------------------------------------------------------------
const canvas  = document.getElementById("canvas");
const ctx     = canvas.getContext("2d");
const tooltip = document.getElementById("tooltip");
const statusEl = document.getElementById("status");

// ---------------------------------------------------------------------------
// Layout constants
// ---------------------------------------------------------------------------
const MARGIN       = { top: 20, right: 30, bottom: 45, left: 140 };
const BAND_H       = 50;
const BAND_GAP     = 40;
const DOT_R        = 2.5;
const HOVER_THRESH = 8;

// ---------------------------------------------------------------------------
// State
// ---------------------------------------------------------------------------
let data      = { DataChannel: [], ActionsQueue: [] };
let viewStart = null;
let viewEnd   = null;
let dataMin   = null;
let dataMax   = null;
let drag      = null;
let hovered   = null;

// Incremental fetch state
let firstFetch  = true;
let lastDcTs    = null;
let lastAqTs    = null;
let session     = null;   // tracks server session (log dir) for reset detection

// ---------------------------------------------------------------------------
// Helpers
// ---------------------------------------------------------------------------
const tsCache = new Map();

function ts(s) {
  if (!tsCache.has(s)) tsCache.set(s, new Date(s).getTime());
  return tsCache.get(s);
}

function lw() { return canvas.width  / (window.devicePixelRatio || 1); }
function lh() { return canvas.height / (window.devicePixelRatio || 1); }
function pw() { return lw() - MARGIN.left - MARGIN.right; }

function t2x(t) { return MARGIN.left + (t - viewStart) / (viewEnd - viewStart) * pw(); }
function x2t(x) { return viewStart + (x - MARGIN.left) / pw() * (viewEnd - viewStart); }

function dcY() { return MARGIN.top + BAND_H / 2; }
function aqY() { return MARGIN.top + BAND_H + BAND_GAP + BAND_H / 2; }

// ---------------------------------------------------------------------------
// Canvas sizing
// ---------------------------------------------------------------------------
function resize() {
  const dpr  = window.devicePixelRatio || 1;
  const rect = canvas.parentElement.getBoundingClientRect();
  const h    = MARGIN.top + BAND_H + BAND_GAP + BAND_H + MARGIN.bottom;

  canvas.width  = rect.width * dpr;
  canvas.height = h * dpr;
  canvas.style.width  = rect.width + "px";
  canvas.style.height = h + "px";

  ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
  render();
}

// ---------------------------------------------------------------------------
// View range
// ---------------------------------------------------------------------------
function resetView() {
  if (dataMin == null) return;
  const range = Math.max(dataMax - dataMin, 1000);
  const pad   = range * 0.05;
  viewStart = dataMin - pad;
  viewEnd   = dataMax + pad;
}

function updateRange() {
  let mn = Infinity, mx = -Infinity;
  for (const d of data.DataChannel)  { const t = ts(d.timestamp); if (t < mn) mn = t; if (t > mx) mx = t; }
  for (const d of data.ActionsQueue) { const t = ts(d.timestamp); if (t < mn) mn = t; if (t > mx) mx = t; }
  if (mn !== Infinity) { dataMin = mn; dataMax = mx; }
}

// ---------------------------------------------------------------------------
// Render
// ---------------------------------------------------------------------------
function render() {
  const w = lw(), h = lh();
  ctx.clearRect(0, 0, w, h);

  if (viewStart == null || viewEnd == null || viewStart >= viewEnd) {
    ctx.fillStyle    = "#555";
    ctx.font         = "14px Courier New";
    ctx.textAlign    = "center";
    ctx.textBaseline = "middle";
    ctx.fillText("waiting for data...", w / 2, h / 2);
    return;
  }

  const p  = pw();
  const dy = dcY();
  const ay = aqY();

  // Band backgrounds
  ctx.fillStyle = "rgba(255, 255, 255, 0.025)";
  ctx.fillRect(MARGIN.left, MARGIN.top, p, BAND_H);
  ctx.fillRect(MARGIN.left, MARGIN.top + BAND_H + BAND_GAP, p, BAND_H);

  // Band borders
  ctx.strokeStyle = "#222";
  ctx.lineWidth   = 1;
  ctx.strokeRect(MARGIN.left, MARGIN.top, p, BAND_H);
  ctx.strokeRect(MARGIN.left, MARGIN.top + BAND_H + BAND_GAP, p, BAND_H);

  // Labels
  ctx.fillStyle    = "#888";
  ctx.font         = "13px Courier New";
  ctx.textAlign    = "right";
  ctx.textBaseline = "middle";
  ctx.fillText("DataChannel",  MARGIN.left - 12, dy);
  ctx.fillText("ActionsQueue", MARGIN.left - 12, ay);

  ctx.fillStyle = "#444";
  ctx.font      = "10px Courier New";
  ctx.fillText("(" + data.DataChannel.length  + ")", MARGIN.left - 12, dy + 14);
  ctx.fillText("(" + data.ActionsQueue.length + ")", MARGIN.left - 12, ay + 14);

  // DC timestamp -> index lookup (for connecting lines)
  const dcMap = new Map();
  data.DataChannel.forEach((d, i) => dcMap.set(d.timestamp, i));

  // Connecting lines (drawn behind dots)
  for (let i = 0; i < data.ActionsQueue.length; i++) {
    const aq = data.ActionsQueue[i];
    if (!aq.data_ts || !dcMap.has(aq.data_ts)) continue;

    const ax = t2x(ts(aq.timestamp));
    const dx = t2x(ts(aq.data_ts));
    const isH = hovered && (
      (hovered.band === "aq" && hovered.idx === i) ||
      (hovered.band === "dc" && hovered.idx === dcMap.get(aq.data_ts))
    );

    ctx.strokeStyle = isH ? "rgba(255, 255, 255, 0.7)" : "rgba(255, 255, 255, 0.15)";
    ctx.lineWidth   = isH ? 2 : 1;
    ctx.setLineDash([4, 4]);
    ctx.beginPath();
    ctx.moveTo(dx, dy);
    ctx.lineTo(ax, ay);
    ctx.stroke();
    ctx.setLineDash([]);
  }

  // DataChannel dots
  for (let i = 0; i < data.DataChannel.length; i++) {
    const x = t2x(ts(data.DataChannel[i].timestamp));
    if (x < MARGIN.left - 5 || x > MARGIN.left + p + 5) continue;

    const isH = hovered && hovered.band === "dc" && hovered.idx === i;
    ctx.fillStyle = isH ? "#7ee8ff" : "rgba(76, 201, 240, 0.6)";
    ctx.beginPath();
    ctx.arc(x, dy, isH ? 6 : DOT_R, 0, Math.PI * 2);
    ctx.fill();
  }

  // ActionsQueue dots
  for (let i = 0; i < data.ActionsQueue.length; i++) {
    const x = t2x(ts(data.ActionsQueue[i].timestamp));
    if (x < MARGIN.left - 5 || x > MARGIN.left + p + 5) continue;

    const isH = hovered && hovered.band === "aq" && hovered.idx === i;
    ctx.fillStyle = isH ? "#ffaa44" : "rgba(247, 127, 0, 0.85)";
    ctx.beginPath();
    ctx.arc(x, ay, isH ? 6 : DOT_R + 1, 0, Math.PI * 2);
    ctx.fill();
  }

  drawAxis(p, h);
}

// ---------------------------------------------------------------------------
// Time axis
// ---------------------------------------------------------------------------
function drawAxis(p, h) {
  const y     = h - MARGIN.bottom + 15;
  const range = viewEnd - viewStart;

  const intervals = [
    50, 100, 200, 500, 1000, 2000, 5000,
    10000, 30000, 60000, 300000, 600000, 3600000
  ];

  let iv = intervals[intervals.length - 1];
  for (const c of intervals) {
    if (range / c <= p / 90) { iv = c; break; }
  }

  const first = Math.ceil(viewStart / iv) * iv;

  ctx.strokeStyle  = "#333";
  ctx.fillStyle    = "#555";
  ctx.font         = "10px Courier New";
  ctx.textAlign    = "center";
  ctx.textBaseline = "top";
  ctx.lineWidth    = 1;

  for (let t = first; t <= viewEnd; t += iv) {
    const x = t2x(t);
    if (x < MARGIN.left || x > MARGIN.left + p) continue;

    ctx.beginPath();
    ctx.moveTo(x, y - 4);
    ctx.lineTo(x, y);
    ctx.stroke();

    const d   = new Date(t);
    const lbl = d.toTimeString().slice(0, 8) + "."
              + String(d.getMilliseconds()).padStart(3, "0");
    ctx.fillText(lbl, x, y + 3);
  }
}

// ---------------------------------------------------------------------------
// Zoom (scroll wheel)
// ---------------------------------------------------------------------------
canvas.addEventListener("wheel", e => {
  e.preventDefault();
  if (viewStart == null) return;

  const rect   = canvas.getBoundingClientRect();
  const mx     = e.clientX - rect.left;
  const mt     = x2t(mx);
  const factor = e.deltaY > 0 ? 1.3 : 0.7;
  const nr     = (viewEnd - viewStart) * factor;

  if (nr < 10) return;

  const r   = (mt - viewStart) / (viewEnd - viewStart);
  viewStart = mt - r * nr;
  viewEnd   = mt + (1 - r) * nr;
  render();
}, { passive: false });

// ---------------------------------------------------------------------------
// Drag (pan)
// ---------------------------------------------------------------------------
canvas.addEventListener("mousedown", e => {
  drag = { startX: e.clientX, vs: viewStart, ve: viewEnd };
  canvas.style.cursor = "grabbing";
});

window.addEventListener("mouseup", () => {
  drag = null;
  canvas.style.cursor = "crosshair";
});

// ---------------------------------------------------------------------------
// Hover + drag move
// ---------------------------------------------------------------------------
window.addEventListener("mousemove", e => {
  if (drag) {
    const dx  = e.clientX - drag.startX;
    const tpp = (drag.ve - drag.vs) / pw();
    viewStart = drag.vs - dx * tpp;
    viewEnd   = drag.ve - dx * tpp;
    render();
    tooltip.style.display = "none";
    return;
  }

  const rect = canvas.getBoundingClientRect();
  const mx = e.clientX - rect.left;
  const my = e.clientY - rect.top;
  const dy = dcY();
  const ay = aqY();

  let found = null;
  if (Math.abs(my - ay) < BAND_H / 2) found = nearest(data.ActionsQueue, mx, "aq");
  if (!found && Math.abs(my - dy) < BAND_H / 2) found = nearest(data.DataChannel, mx, "dc");

  const prevKey = hovered ? hovered.band + hovered.idx : null;
  const newKey  = found   ? found.band   + found.idx   : null;
  if (prevKey !== newKey) { hovered = found; render(); }

  showTooltip(e, found);
});

// ---------------------------------------------------------------------------
// Double-click reset
// ---------------------------------------------------------------------------
canvas.addEventListener("dblclick", () => { resetView(); render(); });

// ---------------------------------------------------------------------------
// Hit-testing
// ---------------------------------------------------------------------------
function nearest(entries, mx, band) {
  let best = null, bestD = HOVER_THRESH;
  for (let i = 0; i < entries.length; i++) {
    const x = t2x(ts(entries[i].timestamp));
    const d = Math.abs(x - mx);
    if (d < bestD) { bestD = d; best = { band, idx: i }; }
  }
  return best;
}

// ---------------------------------------------------------------------------
// Tooltip
// ---------------------------------------------------------------------------
function showTooltip(e, item) {
  if (!item) { tooltip.style.display = "none"; return; }

  const entry = item.band === "dc"
    ? data.DataChannel[item.idx]
    : data.ActionsQueue[item.idx];

  const lines = [];
  lines.push("<b>" + (item.band === "dc" ? "DataChannel" : "ActionsQueue") + "</b>");
  lines.push("timestamp: " + entry.timestamp);
  lines.push("keys: " + entry.keys.join(", "));

  if (item.band === "aq") {
    lines.push("action: " + entry.action_name);
    if (entry.action_params
        && typeof entry.action_params === "object"
        && Object.keys(entry.action_params).length > 0) {
      lines.push("params: " + JSON.stringify(entry.action_params));
    }
    lines.push("data_ts: " + (entry.data_ts || "none (keyboard input)"));
  }

  tooltip.innerHTML      = lines.join("\n");
  tooltip.style.display  = "block";

  let tx = e.clientX + 15;
  let ty = e.clientY - 10;
  tooltip.style.left = tx + "px";
  tooltip.style.top  = ty + "px";

  requestAnimationFrame(() => {
    const tr = tooltip.getBoundingClientRect();
    if (tr.right  > window.innerWidth)  tx = e.clientX - tr.width  - 15;
    if (tr.bottom > window.innerHeight) ty = e.clientY - tr.height - 10;
    tooltip.style.left = tx + "px";
    tooltip.style.top  = ty + "px";
  });
}

// ---------------------------------------------------------------------------
// Incremental data merge
// ---------------------------------------------------------------------------
function mergeEntries(existing, incoming) {
  if (existing.length === 0) return incoming;
  if (incoming.length === 0) return existing;

  const lastExisting = existing[existing.length - 1].timestamp;
  const newItems = incoming.filter(e => e.timestamp > lastExisting);
  if (newItems.length === 0) return existing;

  return existing.concat(newItems);
}

function trackLatestTs(entries, current) {
  if (entries.length === 0) return current;
  const last = entries[entries.length - 1].timestamp;
  return (!current || last > current) ? last : current;
}

function resetClientState() {
  data       = { DataChannel: [], ActionsQueue: [] };
  viewStart  = null;
  viewEnd    = null;
  dataMin    = null;
  dataMax    = null;
  hovered    = null;
  firstFetch = true;
  lastDcTs   = null;
  lastAqTs   = null;
  tsCache.clear();
}

// ---------------------------------------------------------------------------
// Fetch loop
// ---------------------------------------------------------------------------
function fetchData() {
  let url = "/api/data";
  const after = lastDcTs && lastAqTs
    ? (lastDcTs < lastAqTs ? lastDcTs : lastAqTs)
    : lastDcTs || lastAqTs;
  if (after) url += "?after=" + encodeURIComponent(after);

  fetch(url)
    .then(r => r.json())
    .then(d => {
      // Detect session (log dir) change and reset if needed
      if (session !== null && d.session !== session) {
        resetClientState();
      }
      session = d.session;

      data.DataChannel  = mergeEntries(data.DataChannel,  d.DataChannel);
      data.ActionsQueue = mergeEntries(data.ActionsQueue, d.ActionsQueue);

      lastDcTs = trackLatestTs(data.DataChannel,  lastDcTs);
      lastAqTs = trackLatestTs(data.ActionsQueue, lastAqTs);

      updateRange();
      if (firstFetch && dataMin != null) { resetView(); firstFetch = false; }

      render();
      statusEl.textContent =
        data.DataChannel.length + " dc + "
        + data.ActionsQueue.length + " aq \u00b7 "
        + new Date().toLocaleTimeString();
    })
    .catch(err => {
      statusEl.textContent = "error: " + err.message;
    });
}

// ---------------------------------------------------------------------------
// Init
// ---------------------------------------------------------------------------
window.addEventListener("resize", resize);
resize();
fetchData();
setInterval(fetchData, 2000);
</script>

</body>
</html>
